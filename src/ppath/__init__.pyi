import contextlib
import enum
import io
import os
import pathlib
import subprocess
import tempfile
from _typeshed import StrOrBytesPath
from dataclasses import dataclass
from dataclasses import Field
from dataclasses import InitVar
from os import PathLike
from subprocess import CompletedProcess
from subprocess import SubprocessError
from typing import Any
from typing import AnyStr
from typing import IO
from typing import Iterable
from typing import Literal
from typing import MutableMapping
from typing import MutableSequence
from typing import NamedTuple
from typing import Optional
from typing import Sequence
from typing import Sized
from typing import Type
from typing import Union

__all__: tuple[str, ...] = ...
AnyPath = Union[PathLike, AnyStr, IO[AnyStr]]
MACOS: bool = ...
class CalledProcessError(SubprocessError):
    returncode: int
    cmd: Union[StrOrBytesPath, Sequence[StrOrBytesPath]]
    output: Optional[AnyStr]
    stderr: Optional[AnyStr]
    completed: Optional[CompletedProcess]
    def __init__(self, returncode: Optional[int] = ...,
                 cmd: Optional[Union[StrOrBytesPath, Sequence[StrOrBytesPath]]] = ...,
                 output: Optional[AnyStr] = ..., stderr: Optional[AnyStr] = ...,
                 completed: CompletedProcess = ...) -> None: ...
class EnumLower(enum.Enum):
    def _generate_next_value_(self: str, start: int, count: int, last_values: list[Any]) -> Any: ...
class PIs(EnumLower):
    EXISTS: PIs = ...
    IS_DIR: PIs = ...
    IS_FILE: PIs = ...
class PathAccessor:
    stat: Type[os.stat] = os.stat
    open: Type[io.open] = io.open
    listdir: Type[os.listdir] = os.listdir
    scandir: Type[os.scandir] = os.scandir
    chmod: Type[os.chmod] = os.chmod
    mkdir: Type[os.mkdir] = os.mkdir
    unlink: Type[os.unlink] = os.unlink
    link: Type[os.link] = os.link
    rmdir: Type[os.rmdir] = os.rmdir
    rename: Type[os.rename] = os.rename
    replace: Type[os.replace] = os.replace
    symlink: Type[os.symlink] = os.symlink
    def touch(self: Path, path: AnyPath, mode: int = ..., exist_ok: bool = ...) -> None: ...
    readlink: Type[os.link] = os.readlink
    def owner(self: Path, path: AnyPath) -> Optional[str]: ...
    def group(self: Path, path: AnyPath) -> Optional[str]: ...
    getcwd: Type[os.getcwd] = os.getcwd
    expanduser: Type[pathlib._NormalAccessor.expanduser] = os.path.expanduser
    realpath: Type[pathlib._NormalAccessor.realpath] = os.path.realpath
class Path(pathlib.Path, pathlib.PurePosixPath):
    _accessor: PathAccessor = ...
    def __call__(self, name: AnyPath = ..., file: PIs = ..., passwd: Optional[Passwd] = ...,
                 mode: Union[int, str] = ...) -> Path: ...
    def __new__(cls: Type[Path], *args: AnyPath, **kwargs: Any) -> Path: ...
    def __contains__(self, value: Iterable) -> bool: ...
    def __eq__(self, other: Path) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterable[str]: ...
    def __lt__(self, other: Path) -> bool: ...
    def __le__(self, other: Path) -> bool: ...
    def __gt__(self, other: Path) -> bool: ...
    def __ge__(self, other: Path) -> bool: ...
    @property
    def _cparts(self) -> list[str]: ...
    @property
    def _parts(self) -> list[str]: ...
    def access(self, os_mode: int = ..., *, dir_fd: Optional[int] = ..., effective_ids: bool = ...,
               follow_symlinks: bool = ...) -> Optional[bool]: ...
    def add(self, *args: str, exception: bool = ...) -> Path: ...
    def append_text(self, text: str, encoding: str = ..., errors = ...) -> str: ...
    @contextlib.contextmanager
    def cd(self) -> Path: ...
    def chdir(self) -> Path: ...
    def checksum(self, algorithm: Literal['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'] = ...,
                 block_size: int = ...) -> str: ...
    def chmod(self, mode: Optional[Union[int, str]] = ..., effective_ids: bool = ..., exception: bool = ...,
              follow_symlinks: bool = ..., recursive: bool = ...) -> Path: ...
    def chown(self, passwd: Optional[Passwd, str] = ..., effective_ids: bool = ..., exception: bool = ...,
              follow_symlinks: bool = ..., recursive: bool = ...) -> Path: ...
    def cmp(self, other: AnyPath) -> bool: ...
    def cp(self, dest: AnyPath, contents: bool = False, effective_ids: bool = ..., follow_symlinks: bool = ...,
           preserve: bool = ...) -> Path: ...
    def exists(self) -> bool: ...
    @classmethod
    def expandvars(cls, path: Optional[str] = ...) -> Path: ...
    def file_in_parents(self, exception: bool = ..., follow_symlinks: bool = ...) -> Optional[Path]: ...
    def has(self, value: Iterable) -> bool: ...
    def ln(self, dest: AnyPath, force: bool = ...) -> Path: ...
    def mkdir(self, name: AnyPath = ..., passwd: Optional[Passwd] = ..., mode: Union[int, str] = ...,
              effective_ids: bool = ..., follow_symlinks: bool = ...) -> Path: ...
    def realpath(self, exception: bool = ...) -> Path: ...
    def rm(self, *args: str, effective_ids: bool = ..., follow_symlinks: Optional[bool] = ...,
           missing_ok: bool = ...) -> None: ...
    def setid(self, name: Optional[Union[bool, str]], uid: bool = ...) -> Path: ...
    def stats(self, follow_symlinks: bool = ...) -> PathStat: ...
    def sudo(self, force: bool = ..., to_list: bool = ..., os_mode: int = ..., effective_ids: bool = ...,
             follow_symlinks: bool = ...) -> Union[str, list[str]]: ...
    @property
    def text(self) -> str: ...
    @classmethod
    @contextlib.contextmanager
    def tempcd(cls, suffix: Optional[AnyStr] = ..., prefix: Optional[AnyStr] = ...,
               directory: Optional[AnyPath] = ...) -> Path: ...
    @classmethod
    @contextlib.contextmanager
    def tempdir(cls, suffix: Optional[AnyStr] = ..., prefix: Optional[AnyStr] = ...,
               directory: Optional[AnyPath] = ...) -> Path: ...
    @classmethod
    @contextlib.contextmanager
    def tempfile(cls, mode: Literal["r", "w", "a", "x", "r+", "w+", "a+", "x+", "rt", "wt", "at", "xt", "r+t",
                                   "w+t", "a+t", "x+t"] = ..., buffering: int = ..., encoding: Optional[str] = ...,
                 newline: Optional[str] = ..., suffix: Optional[AnyStr] = ..., prefix: Optional[AnyStr] = ...,
                 directory: Optional[AnyPath] = ..., delete: bool = ..., *,
                 errors: Optional[str] = ...) -> TemporaryFileType[str]: ...
    def to_parent(self) -> Path: ...
    def touch(self, name: AnyPath = ..., passwd: Optional[Passwd] = ..., mode: Union[int, str] = ...,
              effective_ids: bool = ..., follow_symlinks: Optional[bool] = ...) -> Path: ...
    def with_suffix(self, suffix: str = ...) -> Path: ...
PathStat = NamedTuple('PathStat', gid=int, group=str, mode=str, own=str, passwd=Passwd, result=os.stat_result,
                      root=bool, sgid=bool, sticky=bool, suid=bool, uid=int, user=str)
@dataclass
class Passwd:
    data: InitVar[Union[int, str, Path]] = ...
    gid: Union[int, str, Field] = ...
    gecos: Union[str, Field] = ...
    group: Union[str, Field] = ...
    groups: Union[dict[str, int], Field] = ...
    home: Union[Path, Field] = ...
    shell: Union[Field, Field] = ...
    uid: Union[int, str, Field] = ...
    user: Union[str, Field] = ...
    def __init__(self, data: Union[int, str, Path] = ...) -> None:...
    def __post_init__(self, data: Union[int, str, Path] = ... ) -> None: ...
    @property
    def is_su(self) -> bool: ...
    @property
    def is_sudo(self) -> bool: ...
    @property
    def is_user(self) -> bool: ...
    @classmethod
    def from_login(cls) -> Passwd: ...
    @classmethod
    def from_root(cls) -> Passwd: ...
    @classmethod
    def from_sudo(cls) -> Passwd: ...
class TemporaryFileType(type(tempfile.NamedTemporaryFile())): path: Path = None
def command(*args, **kwargs) -> subprocess.CompletedProcess:...
def toiter(obj: Any, split: str = ...) -> Union[Sized, MutableMapping, Sequence, MutableSequence]: ...
def which(cmd: str = ...) -> str: ...
